
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/6DJ.ipynb

from expDJ.nb_4Dj import *

# Function to normalize the trainig data and validation data
def normalize_to(train, valid):
    m,s = train.mean(),train.std()
    return normalize(train, m, s), normalize(valid, m, s)

# Reform MNIST data
class LambdaDJ(nn.Module):
    def __init__(self, func):
        super().__init__()
        self.func = func

    def forward(self, x): return self.func(x)

def flatten(x):      return x.view(x.shape[0], -1)
def resize_MNIST(x): return x.view(-1, 1, 28, 28)




class ListContainer():
    def __init__(self, items): self.items = listify(items)
    def __getitem__(self, idx):
        if isinstance(idx, (int,slice)): return self.items[idx]
        if isinstance(idx[0],bool):
            assert len(idx)==len(self) # bool mask
            return [o for m,o in zip(idx,self.items) if m]
        return [self.items[i] for i in idx]
    def __len__(self): return len(self.items)
    def __iter__(self): return iter(self.items)
    def __setitem__(self, i, o): self.items[i] = o
    def __delitem__(self, i): del(self.items[i])
    def __repr__(self):
        res = f'{self.__class__.__name__} ({len(self)} items)\n{self.items[:10]}'
        if len(self)>10: res = res[:-1]+ '...]'
        return res

class Hook():
    def __init__(self, mLyr, func):
        self.hook = mLyr.register_forward_hook(partial(func, self))

    def remove(self): self.hook.remove()
    def __del__(self): self.remove()

def append_stats(hook, mod, inp, outp):
    if not hasattr(hook,'stats'): hook.stats = ([],[], [])
    means,stds, meds = hook.stats
    means.append(outp.data.mean())
    stds.append(outp.data.std())
    meds.append(outp.data.median())

## test


from torch.nn import init

class HooksDJ(ListContainer):
    def  __init__(self, f, ms): # f is the function, m is the model
        super().__init__([Hook(m, f) for m in ms])


    def __enter__(self, *args): return self


    def __exit__(self, *args): self.remove()

    def __del__(self):
        self.remove()

    def __delitem__(self, i):
        self[i].remove
        super.__delitem__(i)


    def remove(self):

        for dx in self:
            dx.remove()




